class Platform
/*
	Class that represents the application Rome2Rio it holds
	the inserted start point and destination the user introduces,
	along with the Graph where all the Nodes(Locations) and also all the possible routes existent
	(all possible ways to go from a pointA to pointB)
*/

instance variables
  private insertedStart:Location;
  private insertedDestination:Location;
  private graph:Graph;
  private all_possible_routes: set of seq of Route;

operations
  public Platform : Graph ==> Platform
	  Platform(g) == (
	  	graph := g;
	  	all_possible_routes := {};
	  	return self
  );
  
  /* ------------------ Getters ------------------ */
  
  public getAllPossibleRoutes : () ==> set of seq of Route
		getAllPossibleRoutes() == (
	  	return all_possible_routes;
	  );
  
  public getAllPossibleRoutesSize : () ==> nat
	  	getAllPossibleRoutesSize() == (
	  	return card all_possible_routes
  	);
  	
  public getInsertedStart : () ==> Location
  getInsertedStart() == (
  	return insertedStart
  );
  
  public getInsertedDestination : () ==> Location
  getInsertedDestination() == (
  	return insertedDestination
  );
  
  public getGraph : () ==> Graph
  getGraph() == (
  	return graph
  );
  
  public getGraphSize : () ==> nat
		getGraphSize() == (
			return graph.getSize();
	);
	
	
  /* ------------------ Setters ------------------ */

  public setStart : nat ==> ()
  setStart(start_pos) == (
  	if graph.locationExistsByID(start_pos)
  	then insertedStart := graph.searchLocationByID(start_pos)
  );
  
  public setDestination : nat ==> ()
	  setDestination(destination_pos) == (
	    if graph.locationExistsByID(destination_pos)
	  	then insertedDestination := graph.searchLocationByID(destination_pos)
  );
  

  
  public getAllRoutes : () ==> () 
  getAllRoutes() == (
  	dcl routes : seq of Route := [];
  	getAllRoutesUtils(insertedStart, routes);
	);
	
	
	public getAllRoutesUtils : Location * seq of Route ==> ()
	getAllRoutesUtils(currLocation, seqRoutes) == (
		for all route in set currLocation.getRoutes() do (
			dcl newRoute: seq of Route := seqRoutes;		
			dcl routeDestinationID : nat := route.getDestination().getID();	
			if routeDestinationID not in set getVisitedLocations(seqRoutes)
			then (
				newRoute(len newRoute + 1) := route
			);
			
			if route.getDestination() = insertedDestination 
			then (
				all_possible_routes := all_possible_routes union {newRoute};
			)
			else (
				dcl numberOfEdgesInDestination: nat := card route.getDestination().getRoutes();
				
				if routeDestinationID not in set getVisitedLocations(seqRoutes) and numberOfEdgesInDestination > 0
				then (
					getAllRoutesUtils(route.getDestination(),newRoute)
				);
			);
		);
	);
	
	public getVisitedLocations: seq of Route ==> set of nat
	getVisitedLocations(route_sequence) == (
		dcl locationsID : set of nat := {insertedStart.getID()};
		for all route in set elems route_sequence do (
			locationsID := {route.getDestination().getID()} union locationsID;
		);
		return locationsID;
	);
	
	public printAllPossiblePaths : () ==> ()
	printAllPossiblePaths() == (
		IO`print("\n");
		IO`print("Start: ");
		IO`println(insertedStart.getName());
		IO`print("Destination: ");
		IO`println(insertedDestination.getName());
		IO`print("--------------------- \n\n");
		if card all_possible_routes > 0
		then (
			dcl local_i : nat1 := 1;
			for all routes in set all_possible_routes do (
				IO`print("Route: ");
				IO`println(local_i);
				printRouteInfo(routes);
				local_i := local_i + 1;
				IO`print("\n");
			);
		)
		else (
			IO`print("Not Possible to reach the Destination from that Starting Point!");
			);
	);
	
	public printRouteInfo : seq of Route ==> ()
	printRouteInfo(seq_of_route) == (
		dcl prevRoute : Route;
		dcl totalTripDuration : nat := 0;
		dcl totalTripCost : nat := 0;
		dcl totalTypeOfTransport : set of Transport := {};
		for i=1 to len seq_of_route do (
				if i=1 
					then (
						IO`print("Travel from: ");
						IO`print(insertedStart.getName());
						IO`print(" to: ");
						IO`print(seq_of_route(i).getDestination().getName());
						IO`print(" transport: ");
						IO`print(seq_of_route(i).getTransport().getName());
						IO`print(" duration of: ");
						IO`print(seq_of_route(i).getDuration());
						IO`print(" with a Price of: ");
						IO`println(seq_of_route(i).getPrice());
						totalTripDuration := totalTripDuration + seq_of_route(i).getDuration();
						totalTripCost := totalTripCost + seq_of_route(i).getPrice();
						totalTypeOfTransport := totalTypeOfTransport union {seq_of_route(i).getTransport()};
					)
					else (
						IO`print("Travel from: ");
						IO`print(prevRoute.getDestination().getName());
						IO`print(" to: ");
						IO`print(seq_of_route(i).getDestination().getName());
						IO`print(" transport: ");
						IO`print(seq_of_route(i).getTransport().getName());
						IO`print(" duration of: ");
						IO`print(seq_of_route(i).getDuration());
						IO`print(" with a Price of: ");
						IO`println(seq_of_route(i).getPrice());
						totalTripDuration := totalTripDuration + seq_of_route(i).getDuration();
						totalTripCost := totalTripCost + seq_of_route(i).getPrice();
						totalTypeOfTransport := totalTypeOfTransport union {seq_of_route(i).getTransport()};
			);
			prevRoute := seq_of_route(i); --used to save the previous route location
		);
		IO`print("\n");
		IO`print("Total travel time: ");
		IO`print(totalTripDuration);
		IO`println(" hours.");
		IO`print("Total travel price: ");
		IO`print(totalTripCost);
		IO`println(" euros.");
		IO`print("Total type of transport: ");
		printTotalTypeOfTransportUsed(totalTypeOfTransport);
		IO`print("\n");
	);
	
	public printTotalTypeOfTransportUsed : set of Transport ==> ()
	printTotalTypeOfTransportUsed(typeOfTransport) == (
		dcl local_i : nat := 0;
		for all transport in set typeOfTransport do (
			if local_i=0
				then 
					IO`print(transport.getName())
				else (
					IO`print(" -- ");
					IO`print(transport.getName());
				);
			local_i := local_i + 1;
		);
	
	)
		
end Platform
